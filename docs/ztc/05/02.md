# SpringBoot 多环境部署 profile(开发环境/生产环境)

## 多环境部署

基本上有以下几个环境：

- 开发环境：dev

  开发的时候使用

- 测试环境：test

  部署到测试环境使用

- 生产环境：prod

  生产环境使用

还要一些公司分得细，在测试环境和生产环境中间还有一个 **预发布环境**

分不同的环境，目的是需要修改一些配置，比如数据库配置、消息队列配置等。

## boot 多环境支持 profile

- application.yml：主配置文件
- `application-{name}.yml`：环境配置（挂件）

通过配置项： `spring.profiles.active:{name}` 来激活对应的配置文件

在 application.yml 中增加 dev 的激活，也就是说：默认是 dev 环境

```yml
spring:
  profiles:
    active: dev
```

application-prod.yml

```yml
spring:
  datasource:
    url: jdbc:mysql://192.168.56.108:3306/foodie-shop-dev?useUnicode=true&characterEncoding=UTF-8&autoReconnect=true
    username: root
    password: root
```

当前项目比较简单，要修改的配置文件也比较少。这里主要说配置文件技巧：

- application.yml：保留全部的配置，只有开放环境需要配置的除外

  比如：myabtis 的日志打印，只有开放环境下需要配置，如果默认配置中也配置上了，那么在 prod 里面就无法取消了，因为如果是空值，应该会报错

  ```yml
  mybatis:
    type-aliases-package: cn.mrcode.foodiedev.pojo    # 实体层
    mapper-locations: classpath:mapper/*.xml          # mapper 层
    configuration:
      log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  ```

  那么这种情况下如何做呢？默认配置只保留如下配置即可，剩余在在 dev 中开启，而 prod 中不需要，则不配置即可

  ```yml
  mybatis:
    type-aliases-package: cn.mrcode.foodiedev.pojo    # 实体层
    mapper-locations: classpath:mapper/*.xml          # mapper 层
  ```

- application-dev.yml：只需要在 dev 环境下需要更改的配置

这样做的好处是：

1. 当你的配置很多的时候，各种环境能比较清晰的知道哪些配置是更改了的

2. 当新增或则减少配置时，能话最小的代价去维护

   比如：公共配置中的配置，在 dev 和 prod 中都没有覆盖，那么只需要维护公共配置文件中的内容即可，而不需要维护所有环节的配置文件内容

  ## profiles 需要更改的地方梳理

由于当前阶段项目中某些配置写得不够好，还需要手动硬编码，这里做一个梳理

1. 在 prod 配置文件中修改的有：
   1. 数据源配置
   2. mybatis 日志打印
2. 项目中直接需要硬编码改变的配置有
   1. `cn.mrcode.foodiedev.resource.FileUpload` 图片加载的配置文件，图片存储目录和图片服务器路径
   2. BaseController 中硬编码的支付中心地址、回调地址信息

## 打包方式

1. jar：服务化概念，后续学完 spring cloud 后，所有的服务打包都是以 jar 包形式
2. war：应用程序的概念，也可以向外提供服务和接口

## 打成 war 包配置

spring boot 默认是 jar 包方式，修改成 war 包方式如下：

1. 修改 api 打成 war 包

   ```xml
   <!--    <packaging>jar</packaging>-->
       <!-- 打包 war 1：由 jar 包改成 war 包 -->
       <packaging>war</packaging>
   ```

2. spring boot 依赖了一个  tomcat-embed-el  的依赖包，该包是由 `spring-boot-starter-web` 引入的 `spring-boot-starter-tomcat` 包引用的，所以需要排除这个包

   ```xml
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-web</artifactId>
               <exclusions>
                   <!-- 打包 war 2：移除内置的 tomcat -->
                   <exclusion>
                       <groupId>org.springframework.boot</groupId>
                       <artifactId>spring-boot-starter-tomcat</artifactId>
                   </exclusion>
               </exclusions>
           </dependency>
   ```

   这个配置方式官网文档也有的。

3. 由于移除了 tomcat 依赖，那么一些依赖包，如 servlet 等就没有了，需要自定义引入

   ```xml
           <!-- 打包 war 3：添加依赖 -->
           <dependency>
               <groupId>javax.servlet</groupId>
               <artifactId>javax.servlet-api</artifactId>
               <scope>provided</scope>
           </dependency>
   ```

   

4. 增加 war 包启动类入口

   ```java
   package cn.mrcode.foodiedev;
   
   import org.springframework.boot.builder.SpringApplicationBuilder;
   import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;
   
   /**
    * war 包启动4: 启动类
    *
    * @author mrcode
    * @date 2021/2/28 21:40
    */
   public class WarStarterApplication extends SpringBootServletInitializer {
       @Override
       protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
           // 指向之前的启动类
           return builder.sources(Application.class);
       }
   }
   ```

5. application.yml 配置文件中修改为 prod 环境

   ```yml
   spring:
     profiles:
       active: prod
   ```

   还是比较麻烦的，需要各种地方修改配置文件

最后运行 maven 的 install 或则 package，就打成 war 包了。

## 部署到服务器

将 war 包修改名称为 `foodie-dev-api.war` 然后上传到后端服务器  192.168.56.107 的 tomcat 目录 `/usr/local/tomcat-api/webapps` 下

没有问题的话，应该就可以通过地址 `http://192.168.56.107:8080/foodie-dev-api/hello`  访问到服务了

同样也可以访问 swagger 页面：`http://192.168.56.107:8080/foodie-dev-api/doc.html`



